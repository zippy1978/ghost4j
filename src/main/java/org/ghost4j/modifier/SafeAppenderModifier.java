/*
 * Ghost4J: a Java wrapper for Ghostscript API.
 *
 * Distributable under LGPL license.
 * See terms of license at http://www.gnu.org/licenses/lgpl.html.
 */
package org.ghost4j.modifier;

import java.io.IOException;
import java.io.Serializable;
import java.util.Map;

import org.ghost4j.Ghostscript;
import org.ghost4j.GhostscriptException;
import org.ghost4j.document.Document;
import org.ghost4j.document.DocumentException;
import org.ghost4j.document.PDFDocument;
import org.ghost4j.document.PSDocument;
import org.ghost4j.util.DiskStore;

/**
 * Safe appender : appends a document to another one. Document types can be
 * mixed (example: append PDF to PS). The modified document returned by the
 * modify method is always the same as the source document provided. The
 * parameter APPEND_DOCUMENT (the document to append to the source one) must be
 * passed to the modify method. Important : this appender is safe even for
 * PostScript document generated by diffrent softwares.
 * 
 * @author Gilles Grousset (gi.grousset@gmail.com)
 * 
 */
public class SafeAppenderModifier extends AbstractRemoteModifier {

	public static final String PARAMETER_APPEND_DOCUMENT = "APPEND_DOCUMENT";

	public SafeAppenderModifier() {

		// set supported classes
		supportedDocumentClasses = new Class[] { PSDocument.class,
				PDFDocument.class };
	}

	/**
	 * Main method used to start the modifier in standalone 'slave mode'.
	 * 
	 * @param args
	 * @throws ModifierException
	 */
	public static void main(String args[]) throws ModifierException {
		startRemoteModifier(new SafeAppenderModifier());
	}

	@Override
	protected Document run(Document source, Map<String, Serializable> parameters)
			throws ModifierException, DocumentException, IOException {

		// check that document to append is provided as parameter
		Document append = (Document) parameters.get(PARAMETER_APPEND_DOCUMENT);
		if (append == null) {
			throw new ModifierException(
					"No document to append found in parameters map");
		}

		// get Ghostscript instance
		Ghostscript gs = Ghostscript.getInstance();

		// generate a unique diskstore key for source and append documents, and
		// for output file
		DiskStore diskStore = DiskStore.getInstance();
		String sourceDiskStoreKey = diskStore.generateUniqueKey();
		String appendDiskStoreKey = diskStore.generateUniqueKey();
		String outputDiskStoreKey = diskStore.generateUniqueKey();

		// write source and append to files
		source.write(diskStore.addFile(sourceDiskStoreKey));
		append.write(diskStore.addFile(appendDiskStoreKey));

		// guess output device from source document type
		String deviceName = "pswrite";
		try {
			if (source.getType().equals(Document.TYPE_PDF)) {
				deviceName = "pdfwrite";
			} else {
				// for Postscript : use ps2write if available
				if (this.isDeviceSupported("ps2write")) {
					deviceName = "ps2write";
				} else {
					deviceName = "pswrite";
				}
			}
		} catch (GhostscriptException e) {
			throw new ModifierException(e);
		}

		// prepare args
		String[] gsArgs = {
				"-psconv",
				"-dNOPAUSE",
				"-dSAFER",
				"-dBATCH",
				"-sDEVICE=" + deviceName,
				"-sOutputFile="
						+ diskStore.addFile(outputDiskStoreKey)
						.getAbsolutePath(), "-q", "-f",
						diskStore.getFile(sourceDiskStoreKey).getAbsolutePath(),
						diskStore.getFile(appendDiskStoreKey).getAbsolutePath() };

		Document result = null;

		try {

			// execute and exit interpreter
			synchronized (gs) {
				gs.initialize(gsArgs);
				gs.exit();
			}

			// load obtained document (same type as source document)
			if (source.getType().equals(Document.TYPE_PDF)) {
				result = new PDFDocument();
			} else if (source.getType().equals(Document.TYPE_POSTSCRIPT)) {
				result = new PSDocument();
			}
			result.load(diskStore.getFile(outputDiskStoreKey));

		} catch (GhostscriptException e) {

			throw new ModifierException(e);

		} finally {

			// delete Ghostscript instance
			try {
				Ghostscript.deleteInstance();
			} catch (GhostscriptException e) {
				throw new ModifierException(e);
			}

			// remove temporary files
			diskStore.removeFile(outputDiskStoreKey);
			diskStore.removeFile(sourceDiskStoreKey);
			diskStore.removeFile(appendDiskStoreKey);
		}

		return result;
	}
}
